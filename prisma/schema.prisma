generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Provider {
  id           String       @id @default(uuid())
  slug         String       @unique
  name         String
  description  String?
  website      String?
  category     String       @default("other")
  tags         String
  capabilities String
  isApproved   Boolean      @default(true)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  pricingModel String?
  developerUrl String?
  docsUrl      String?
  billingUrl   String?
  repositories Repository[] @relation("ProviderToRepository")
}

model Repository {
  id                  String           @id @default(uuid())
  githubId            String?          @unique
  name                String
  fullName            String
  nameWithOwner       String
  url                 String
  description         String?
  isPrivate           Boolean          @default(false)
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  pushedAt            DateTime?
  language            String?
  defaultBranch       String?
  homepageUrl         String?
  customUrl           String?
  apiSpec             String?
  businessCanvas      BusinessCanvas?
  capabilities        Capability[]
  deployments         Deployment[]
  interfaces          Interface[]
  outgoingConnections RepoConnection[] @relation("SourceRepo")
  incomingConnections RepoConnection[] @relation("TargetRepo")
  health              RepoHealth?
  tasks               RepoTask[]
  technologies        Technology[]
  providers           Provider[]       @relation("ProviderToRepository")
}

model Deployment {
  id             String     @id @default(uuid())
  repositoryId   String
  provider       String
  url            String?
  status         String?
  lastDeployedAt DateTime?
  detectedAt     DateTime   @default(now())
  repository     Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  verificationStatus String?    @default("PENDING") // VERIFIED, FAILED, PENDING
  verificationProof  String?    // URL or text evidence
  verifiedAt         DateTime?
}

model Technology {
  id           String     @id @default(uuid())
  repositoryId String
  name         String
  category     String?
  version      String?
  detectedAt   DateTime   @default(now())
  repository   Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
}

model Interface {
  id           String     @id @default(uuid())
  repositoryId String
  type         String?
  direction    String?
  details      String?
  detectedAt   DateTime   @default(now())
  repository   Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
}

model RepoHealth {
  id                        String     @id @default(uuid())
  repositoryId              String     @unique
  outdatedDependenciesCount Int        @default(0)
  vulnerabilitiesCount      Int        @default(0)
  lastCheckedAt             DateTime   @default(now())
  healthScore               Int?
  repository                Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
}

model CostSnapshot {
  id                  String   @id @default(uuid())
  date                DateTime @default(now())
  totalMonthlyCostEst Decimal?
  supabaseCostEst     Decimal?
  details             String?
}

model HealthSnapshot {
  id                        String   @id @default(uuid())
  date                      DateTime @default(now())
  totalRepositories         Int
  outdatedDependenciesCount Int
  vulnerabilitiesCount      Int
  healthScore               Int      @default(0)
}

model SyncLog {
  id        String   @id @default(uuid())
  status    String
  message   String
  details   String?
  createdAt DateTime @default(now())
}

model AIReport {
  id        String   @id @default(uuid())
  content   String
  createdAt DateTime @default(now())
}

model RepoTask {
  id           String      @id @default(uuid())
  repositoryId String?
  title        String
  description  String?
  reference    String?
  status       String      @default("OPEN")
  priority     String      @default("MEDIUM")
  type         String      @default("MAINTENANCE")
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  repository   Repository? @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
}

model Capability {
  id           String     @id @default(uuid())
  repositoryId String
  name         String
  category     String?
  source       String?
  confidence   Float      @default(1.0)
  detectedAt   DateTime   @default(now())
  repository   Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
}

model RepoConnection {
  sourceRepoId String
  targetRepoId String
  type         String
  detectedAt   DateTime   @default(now())
  sourceRepo   Repository @relation("SourceRepo", fields: [sourceRepoId], references: [id], onDelete: Cascade)
  targetRepo   Repository @relation("TargetRepo", fields: [targetRepoId], references: [id], onDelete: Cascade)

  @@id([sourceRepoId, targetRepoId])
}

model BusinessCanvas {
  id                    String     @id @default(uuid())
  repositoryId          String     @unique
  valueProposition      String?
  customerSegments      String?
  revenueStreams        String?
  costStructure         String?
  updatedAt             DateTime   @default(now())
  consolidationGroup    String?
  estimatedARR          Decimal?
  marketSize            String?
  monetizationPotential String?
  repository            Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
}

model ArchitectureDecision {
  id           String   @id @default(uuid())
  title        String   @unique
  status       String   @default("PROPOSED")
  context      String
  decision     String
  consequences String
  tags         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model RepositoryFavorite {
  id           String   @id @default(uuid())
  userId       String
  repositoryId String
  createdAt    DateTime @default(now())

  @@unique([userId, repositoryId])
  @@index([userId, createdAt])
}

model User {
  id            String         @id @default(uuid())
  name          String?
  email         String         @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          String         @default("VIEWER")
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  accounts      Account[]
  auditLogs     AuditLog[]
  notifications Notification[]
  sessions      Session[]
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      String
  severity  String   @default("INFO")
  title     String
  message   String
  metadata  String?
  isRead    Boolean  @default(false)
  link      String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@index([type, severity])
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String
  action    String
  entity    String
  entityId  String?
  changes   String?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SecurityScan {
  id              String                  @id @default(uuid())
  repositoryId    String
  scanType        String
  status          String                  @default("PENDING")
  startedAt       DateTime                @default(now())
  completedAt     DateTime?
  summary         String?
  vulnerabilities SecurityVulnerability[]

  @@index([repositoryId, status])
  @@index([repositoryId, startedAt])
  @@index([status, scanType])
}

model SecurityVulnerability {
  id              String       @id @default(uuid())
  scanId          String
  severity        String
  type            String
  title           String
  description     String
  affectedPackage String?
  currentVersion  String?
  fixedVersion    String?
  cveId           String?
  cvssScore       Float?
  status          String       @default("OPEN")
  detectedAt      DateTime     @default(now())
  fixedAt         DateTime?
  scan            SecurityScan @relation(fields: [scanId], references: [id], onDelete: Cascade)

  @@index([scanId, status])
  @@index([severity, status])
  @@index([status, detectedAt])
}

model TestRun {
  id           String       @id @default(uuid())
  repositoryId String
  branch       String?
  commitSha    String?
  status       String
  totalTests   Int          @default(0)
  passedTests  Int          @default(0)
  failedTests  Int          @default(0)
  skippedTests Int          @default(0)
  coverage     Float?
  duration     Int?
  startedAt    DateTime     @default(now())
  completedAt  DateTime?
  results      TestResult[]

  @@index([repositoryId, startedAt])
  @@index([repositoryId, status])
  @@index([status, startedAt])
}

model TestResult {
  id           String   @id @default(uuid())
  testRunId    String
  testName     String
  filePath     String?
  status       String
  duration     Int?
  errorMessage String?
  errorStack   String?
  flakyScore   Float    @default(0)
  executedAt   DateTime @default(now())
  testRun      TestRun  @relation(fields: [testRunId], references: [id], onDelete: Cascade)

  @@index([testRunId, status])
  @@index([testName, flakyScore])
  @@index([status, executedAt])
}

model DependencyNode {
  id               String           @id @default(uuid())
  repositoryId     String
  packageName      String
  version          String
  type             String
  ecosystem        String
  latestVersion    String?
  isOutdated       Boolean          @default(false)
  hasVulnerability Boolean          @default(false)
  license          String?
  detectedAt       DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  dependents       DependencyEdge[] @relation("DependencySource")
  dependencies     DependencyEdge[] @relation("DependencyTarget")
}

model DependencyEdge {
  id           String         @id @default(uuid())
  sourceId     String
  targetId     String
  versionRange String?
  source       DependencyNode @relation("DependencySource", fields: [sourceId], references: [id], onDelete: Cascade)
  target       DependencyNode @relation("DependencyTarget", fields: [targetId], references: [id], onDelete: Cascade)

  @@unique([sourceId, targetId])
}

model AICodeReview {
  id            String   @id @default(uuid())
  repositoryId  String
  prNumber      Int?
  commitSha     String?
  language      String?
  analysis      String
  suggestions   String
  securityScore Float?
  qualityScore  Float?
  createdAt     DateTime @default(now())
}

model PredictiveAnalytics {
  id             String   @id @default(uuid())
  repositoryId   String
  predictionType String
  confidence     Float
  prediction     String
  actualOutcome  String?
  predictionDate DateTime @default(now())
  targetDate     DateTime
  wasAccurate    Boolean?
}

model UpdatePlan {
  id            String            @id @default(uuid())
  title         String
  description   String?
  status        String            @default("PLANNED")
  priority      String            @default("MEDIUM")
  affectedRepos String
  dependencies  String
  testStrategy  String?
  rollbackPlan  String?
  createdAt     DateTime          @default(now())
  scheduledFor  DateTime?
  startedAt     DateTime?
  completedAt   DateTime?
  updates       UpdateExecution[]
}

model UpdateExecution {
  id           String     @id @default(uuid())
  planId       String
  repositoryId String
  packageName  String
  fromVersion  String
  toVersion    String
  status       String     @default("PENDING")
  prUrl        String?
  logs         String?
  startedAt    DateTime?
  completedAt  DateTime?
  plan         UpdatePlan @relation(fields: [planId], references: [id], onDelete: Cascade)
}
